import {
  scale
} from "./chunk-UYDFXFL5.js";
import "./chunk-6A2TAOKG.js";
import "./chunk-M6MB33T7.js";
import {
  SvelteComponentDev,
  add_location,
  add_render_callback,
  append_hydration_dev,
  append_styles,
  attr_dev,
  bubble,
  check_outros,
  children,
  claim_component,
  claim_element,
  claim_space,
  claim_svg_element,
  claim_text,
  compute_slots,
  create_component,
  create_in_transition,
  create_slot,
  destroy_component,
  detach_dev,
  dispatch_dev,
  element,
  empty,
  get_all_dirty_from_scope,
  get_slot_changes,
  group_outros,
  init,
  insert_hydration_dev,
  listen_dev,
  mount_component,
  noop,
  onMount,
  safe_not_equal,
  set_data_dev,
  set_style,
  space,
  src_url_equal,
  svg_element,
  text,
  transition_in,
  transition_out,
  update_slot_base,
  validate_slots
} from "./chunk-RVLVW3YK.js";
import "./chunk-UXIASGQL.js";

// node_modules/svelte-youtube-embed/Button.svelte
var file = "node_modules/svelte-youtube-embed/Button.svelte";
function add_css(target) {
  append_styles(target, "svelte-qc0w97", "button.svelte-qc0w97{all:unset}button.svelte-qc0w97,.play-button.svelte-qc0w97{display:grid;place-items:center;height:80px;width:80px;position:absolute;top:0;right:0;bottom:0;left:0;margin:auto;cursor:pointer}\n/*# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiQnV0dG9uLnN2ZWx0ZSIsIm1hcHBpbmdzIjoiQUF5QkUsb0JBQU8sQ0FDTCxHQUFHLENBQUUsS0FDUCxDQUNBLG9CQUFNLENBQ04sMEJBQWEsQ0FDWCxPQUFPLENBQUUsSUFBSSxDQUNiLFdBQVcsQ0FBRSxNQUFNLENBQ25CLE1BQU0sQ0FBRSxJQUFJLENBQ1osS0FBSyxDQUFFLElBQUksQ0FDWCxRQUFRLENBQUUsUUFBUSxDQUNsQixHQUFHLENBQUUsQ0FBQyxDQUNOLEtBQUssQ0FBRSxDQUFDLENBQ1IsTUFBTSxDQUFFLENBQUMsQ0FDVCxJQUFJLENBQUUsQ0FBQyxDQUNQLE1BQU0sQ0FBRSxJQUFJLENBQ1osTUFBTSxDQUFFLE9BQ1YiLCJuYW1lcyI6W10sInNvdXJjZXMiOlsiQnV0dG9uLnN2ZWx0ZSJdfQ== */");
}
function create_else_block(ctx) {
  let button;
  let svg;
  let path;
  let mounted;
  let dispose;
  const block = {
    c: function create() {
      button = element("button");
      svg = svg_element("svg");
      path = svg_element("path");
      this.h();
    },
    l: function claim(nodes) {
      button = claim_element(nodes, "BUTTON", { class: true });
      var button_nodes = children(button);
      svg = claim_svg_element(button_nodes, "svg", {
        xmlns: true,
        "aria-hidden": true,
        class: true,
        viewBox: true
      });
      var svg_nodes = children(svg);
      path = claim_svg_element(svg_nodes, "path", { fill: true, d: true });
      children(path).forEach(detach_dev);
      svg_nodes.forEach(detach_dev);
      button_nodes.forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(path, "fill", "#ff4e45");
      attr_dev(path, "d", "m10 15 5.19-3L10 9v6m11.56-7.83c.13.47.22 1.1.28 1.9.07.8.1 1.49.1 2.09L22 12c0 2.19-.16 3.8-.44 4.83-.25.9-.83 1.48-1.73 1.73-.47.13-1.33.22-2.65.28-1.3.07-2.49.1-3.59.1L12 19c-4.19 0-6.8-.16-7.83-.44-.9-.25-1.48-.83-1.73-1.73-.13-.47-.22-1.1-.28-1.9-.07-.8-.1-1.49-.1-2.09L2 12c0-2.19.16-3.8.44-4.83.25-.9.83-1.48 1.73-1.73.47-.13 1.33-.22 2.65-.28 1.3-.07 2.49-.1 3.59-.1L12 5c4.19 0 6.8.16 7.83.44.9.25 1.48.83 1.73 1.73Z");
      add_location(path, file, 16, 6, 313);
      attr_dev(svg, "xmlns", "http://www.w3.org/2000/svg");
      attr_dev(svg, "aria-hidden", "true");
      attr_dev(svg, "class", "iconify iconify--mdi");
      attr_dev(svg, "viewBox", "0 0 24 24");
      add_location(svg, file, 10, 5, 169);
      attr_dev(button, "class", "svelte-qc0w97");
      add_location(button, file, 9, 2, 147);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, button, anchor);
      append_hydration_dev(button, svg);
      append_hydration_dev(svg, path);
      if (!mounted) {
        dispose = listen_dev(
          button,
          "click",
          /*click_handler_1*/
          ctx[4],
          false,
          false,
          false,
          false
        );
        mounted = true;
      }
    },
    p: noop,
    i: noop,
    o: noop,
    d: function destroy(detaching) {
      if (detaching)
        detach_dev(button);
      mounted = false;
      dispose();
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_else_block.name,
    type: "else",
    source: "(9:0) {:else}",
    ctx
  });
  return block;
}
function create_if_block(ctx) {
  let div;
  let current;
  let mounted;
  let dispose;
  const default_slot_template = (
    /*#slots*/
    ctx[2].default
  );
  const default_slot = create_slot(
    default_slot_template,
    ctx,
    /*$$scope*/
    ctx[1],
    null
  );
  const block = {
    c: function create() {
      div = element("div");
      if (default_slot)
        default_slot.c();
      this.h();
    },
    l: function claim(nodes) {
      div = claim_element(nodes, "DIV", { class: true });
      var div_nodes = children(div);
      if (default_slot)
        default_slot.l(div_nodes);
      div_nodes.forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(div, "class", "play-button svelte-qc0w97");
      add_location(div, file, 5, 2, 80);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, div, anchor);
      if (default_slot) {
        default_slot.m(div, null);
      }
      current = true;
      if (!mounted) {
        dispose = listen_dev(
          div,
          "click",
          /*click_handler*/
          ctx[3],
          false,
          false,
          false,
          false
        );
        mounted = true;
      }
    },
    p: function update(ctx2, dirty) {
      if (default_slot) {
        if (default_slot.p && (!current || dirty & /*$$scope*/
        2)) {
          update_slot_base(
            default_slot,
            default_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[1],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[1]
            ) : get_slot_changes(
              default_slot_template,
              /*$$scope*/
              ctx2[1],
              dirty,
              null
            ),
            null
          );
        }
      }
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(default_slot, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(default_slot, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching)
        detach_dev(div);
      if (default_slot)
        default_slot.d(detaching);
      mounted = false;
      dispose();
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block.name,
    type: "if",
    source: "(5:0) {#if isCustomPlayButton}",
    ctx
  });
  return block;
}
function create_fragment(ctx) {
  let current_block_type_index;
  let if_block;
  let if_block_anchor;
  let current;
  const if_block_creators = [create_if_block, create_else_block];
  const if_blocks = [];
  function select_block_type(ctx2, dirty) {
    if (
      /*isCustomPlayButton*/
      ctx2[0]
    )
      return 0;
    return 1;
  }
  current_block_type_index = select_block_type(ctx, -1);
  if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
  const block = {
    c: function create() {
      if_block.c();
      if_block_anchor = empty();
    },
    l: function claim(nodes) {
      if_block.l(nodes);
      if_block_anchor = empty();
    },
    m: function mount(target, anchor) {
      if_blocks[current_block_type_index].m(target, anchor);
      insert_hydration_dev(target, if_block_anchor, anchor);
      current = true;
    },
    p: function update(ctx2, [dirty]) {
      let previous_block_index = current_block_type_index;
      current_block_type_index = select_block_type(ctx2, dirty);
      if (current_block_type_index === previous_block_index) {
        if_blocks[current_block_type_index].p(ctx2, dirty);
      } else {
        group_outros();
        transition_out(if_blocks[previous_block_index], 1, 1, () => {
          if_blocks[previous_block_index] = null;
        });
        check_outros();
        if_block = if_blocks[current_block_type_index];
        if (!if_block) {
          if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx2);
          if_block.c();
        } else {
          if_block.p(ctx2, dirty);
        }
        transition_in(if_block, 1);
        if_block.m(if_block_anchor.parentNode, if_block_anchor);
      }
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(if_block);
      current = true;
    },
    o: function outro(local) {
      transition_out(if_block);
      current = false;
    },
    d: function destroy(detaching) {
      if_blocks[current_block_type_index].d(detaching);
      if (detaching)
        detach_dev(if_block_anchor);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance($$self, $$props, $$invalidate) {
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("Button", slots, ["default"]);
  let { isCustomPlayButton } = $$props;
  $$self.$$.on_mount.push(function() {
    if (isCustomPlayButton === void 0 && !("isCustomPlayButton" in $$props || $$self.$$.bound[$$self.$$.props["isCustomPlayButton"]])) {
      console.warn("<Button> was created without expected prop 'isCustomPlayButton'");
    }
  });
  const writable_props = ["isCustomPlayButton"];
  Object.keys($$props).forEach((key) => {
    if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$" && key !== "slot")
      console.warn(`<Button> was created with unknown prop '${key}'`);
  });
  function click_handler(event) {
    bubble.call(this, $$self, event);
  }
  function click_handler_1(event) {
    bubble.call(this, $$self, event);
  }
  $$self.$$set = ($$props2) => {
    if ("isCustomPlayButton" in $$props2)
      $$invalidate(0, isCustomPlayButton = $$props2.isCustomPlayButton);
    if ("$$scope" in $$props2)
      $$invalidate(1, $$scope = $$props2.$$scope);
  };
  $$self.$capture_state = () => ({ isCustomPlayButton });
  $$self.$inject_state = ($$props2) => {
    if ("isCustomPlayButton" in $$props2)
      $$invalidate(0, isCustomPlayButton = $$props2.isCustomPlayButton);
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  return [isCustomPlayButton, $$scope, slots, click_handler, click_handler_1];
}
var Button = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance, create_fragment, safe_not_equal, { isCustomPlayButton: 0 }, add_css);
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "Button",
      options,
      id: create_fragment.name
    });
  }
  get isCustomPlayButton() {
    throw new Error("<Button>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set isCustomPlayButton(value) {
    throw new Error("<Button>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
};
var Button_default = Button;

// node_modules/svelte-youtube-embed/Iframe.svelte
var file2 = "node_modules/svelte-youtube-embed/Iframe.svelte";
function add_css2(target) {
  append_styles(target, "svelte-11gebsu", "iframe.svelte-11gebsu{height:auto;aspect-ratio:var(--aspect-ratio);width:100%}\n/*# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiSWZyYW1lLnN2ZWx0ZSIsIm1hcHBpbmdzIjoiQUFpQkUscUJBQU8sQ0FDTCxNQUFNLENBQUUsSUFBSSxDQUNaLFlBQVksQ0FBRSxJQUFJLGNBQWMsQ0FBQyxDQUNqQyxLQUFLLENBQUUsSUFDVCIsIm5hbWVzIjpbXSwic291cmNlcyI6WyJJZnJhbWUuc3ZlbHRlIl19 */");
}
function create_fragment2(ctx) {
  let iframe;
  let iframe_src_value;
  let iframe_intro;
  const block = {
    c: function create() {
      iframe = element("iframe");
      this.h();
    },
    l: function claim(nodes) {
      iframe = claim_element(nodes, "IFRAME", {
        src: true,
        title: true,
        frameborder: true,
        allow: true,
        class: true
      });
      children(iframe).forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      if (!src_url_equal(iframe.src, iframe_src_value = "https://www.youtube.com/embed/" + /*id*/
      ctx[1] + "?autoplay=1&rel=0"))
        attr_dev(iframe, "src", iframe_src_value);
      attr_dev(
        iframe,
        "title",
        /*title*/
        ctx[0]
      );
      attr_dev(iframe, "frameborder", "0");
      attr_dev(iframe, "allow", "autoplay; picture-in-picture; clipboard-write");
      iframe.allowFullscreen = true;
      attr_dev(iframe, "class", "svelte-11gebsu");
      add_location(iframe, file2, 7, 0, 137);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, iframe, anchor);
    },
    p: function update(new_ctx, [dirty]) {
      ctx = new_ctx;
      if (dirty & /*id*/
      2 && !src_url_equal(iframe.src, iframe_src_value = "https://www.youtube.com/embed/" + /*id*/
      ctx[1] + "?autoplay=1&rel=0")) {
        attr_dev(iframe, "src", iframe_src_value);
      }
      if (dirty & /*title*/
      1) {
        attr_dev(
          iframe,
          "title",
          /*title*/
          ctx[0]
        );
      }
    },
    i: function intro(local) {
      if (!iframe_intro) {
        add_render_callback(() => {
          iframe_intro = create_in_transition(
            iframe,
            scale,
            /*animations*/
            ctx[2] ? { delay: 500, duration: 800 } : {}
          );
          iframe_intro.start();
        });
      }
    },
    o: noop,
    d: function destroy(detaching) {
      if (detaching)
        detach_dev(iframe);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment2.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance2($$self, $$props, $$invalidate) {
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("Iframe", slots, []);
  let { title = "" } = $$props;
  let { id = "" } = $$props;
  let { animations } = $$props;
  $$self.$$.on_mount.push(function() {
    if (animations === void 0 && !("animations" in $$props || $$self.$$.bound[$$self.$$.props["animations"]])) {
      console.warn("<Iframe> was created without expected prop 'animations'");
    }
  });
  const writable_props = ["title", "id", "animations"];
  Object.keys($$props).forEach((key) => {
    if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$" && key !== "slot")
      console.warn(`<Iframe> was created with unknown prop '${key}'`);
  });
  $$self.$$set = ($$props2) => {
    if ("title" in $$props2)
      $$invalidate(0, title = $$props2.title);
    if ("id" in $$props2)
      $$invalidate(1, id = $$props2.id);
    if ("animations" in $$props2)
      $$invalidate(2, animations = $$props2.animations);
  };
  $$self.$capture_state = () => ({ scale, title, id, animations });
  $$self.$inject_state = ($$props2) => {
    if ("title" in $$props2)
      $$invalidate(0, title = $$props2.title);
    if ("id" in $$props2)
      $$invalidate(1, id = $$props2.id);
    if ("animations" in $$props2)
      $$invalidate(2, animations = $$props2.animations);
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  return [title, id, animations];
}
var Iframe = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance2, create_fragment2, safe_not_equal, { title: 0, id: 1, animations: 2 }, add_css2);
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "Iframe",
      options,
      id: create_fragment2.name
    });
  }
  get title() {
    throw new Error("<Iframe>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set title(value) {
    throw new Error("<Iframe>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get id() {
    throw new Error("<Iframe>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set id(value) {
    throw new Error("<Iframe>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get animations() {
    throw new Error("<Iframe>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set animations(value) {
    throw new Error("<Iframe>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
};
var Iframe_default = Iframe;

// node_modules/svelte-youtube-embed/Image.svelte
var file3 = "node_modules/svelte-youtube-embed/Image.svelte";
function add_css3(target) {
  append_styles(target, "svelte-hw9fhp", "img.svelte-hw9fhp{height:auto;aspect-ratio:var(--aspect-ratio);width:100%}\n/*# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiSW1hZ2Uuc3ZlbHRlIiwibWFwcGluZ3MiOiJBQW1CRSxpQkFBSSxDQUNGLE1BQU0sQ0FBRSxJQUFJLENBQ1osWUFBWSxDQUFFLElBQUksY0FBYyxDQUFDLENBQ2pDLEtBQUssQ0FBRSxJQUNUIiwibmFtZXMiOltdLCJzb3VyY2VzIjpbIkltYWdlLnN2ZWx0ZSJdfQ== */");
}
function create_key_block(ctx) {
  let img;
  let img_src_value;
  let img_alt_value;
  const block = {
    c: function create() {
      img = element("img");
      this.h();
    },
    l: function claim(nodes) {
      img = claim_element(nodes, "IMG", {
        src: true,
        title: true,
        alt: true,
        referrerpolicy: true,
        class: true
      });
      this.h();
    },
    h: function hydrate() {
      if (!src_url_equal(img.src, img_src_value = "https://i.ytimg.com/vi/" + /*id*/
      ctx[0] + "/" + /*altThumb*/
      (ctx[2] ? "hqdefault" : "maxresdefault") + ".jpg"))
        attr_dev(img, "src", img_src_value);
      attr_dev(
        img,
        "title",
        /*title*/
        ctx[1]
      );
      attr_dev(img, "alt", img_alt_value = "Youtube video: " + /*title*/
      ctx[1]);
      attr_dev(img, "referrerpolicy", "no-referrer");
      attr_dev(img, "class", "svelte-hw9fhp");
      add_location(img, file3, 8, 2, 136);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, img, anchor);
    },
    p: function update(ctx2, dirty) {
      if (dirty & /*id, altThumb*/
      5 && !src_url_equal(img.src, img_src_value = "https://i.ytimg.com/vi/" + /*id*/
      ctx2[0] + "/" + /*altThumb*/
      (ctx2[2] ? "hqdefault" : "maxresdefault") + ".jpg")) {
        attr_dev(img, "src", img_src_value);
      }
      if (dirty & /*title*/
      2) {
        attr_dev(
          img,
          "title",
          /*title*/
          ctx2[1]
        );
      }
      if (dirty & /*title*/
      2 && img_alt_value !== (img_alt_value = "Youtube video: " + /*title*/
      ctx2[1])) {
        attr_dev(img, "alt", img_alt_value);
      }
    },
    d: function destroy(detaching) {
      if (detaching)
        detach_dev(img);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_key_block.name,
    type: "key",
    source: "(8:0) {#key play}",
    ctx
  });
  return block;
}
function create_fragment3(ctx) {
  let previous_key = (
    /*play*/
    ctx[3]
  );
  let key_block_anchor;
  let key_block = create_key_block(ctx);
  const block = {
    c: function create() {
      key_block.c();
      key_block_anchor = empty();
    },
    l: function claim(nodes) {
      key_block.l(nodes);
      key_block_anchor = empty();
    },
    m: function mount(target, anchor) {
      key_block.m(target, anchor);
      insert_hydration_dev(target, key_block_anchor, anchor);
    },
    p: function update(ctx2, [dirty]) {
      if (dirty & /*play*/
      8 && safe_not_equal(previous_key, previous_key = /*play*/
      ctx2[3])) {
        key_block.d(1);
        key_block = create_key_block(ctx2);
        key_block.c();
        key_block.m(key_block_anchor.parentNode, key_block_anchor);
      } else {
        key_block.p(ctx2, dirty);
      }
    },
    i: noop,
    o: noop,
    d: function destroy(detaching) {
      if (detaching)
        detach_dev(key_block_anchor);
      key_block.d(detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment3.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance3($$self, $$props, $$invalidate) {
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("Image", slots, []);
  let { id = "" } = $$props;
  let { title = "" } = $$props;
  let { altThumb = "" } = $$props;
  let { play = false } = $$props;
  const writable_props = ["id", "title", "altThumb", "play"];
  Object.keys($$props).forEach((key) => {
    if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$" && key !== "slot")
      console.warn(`<Image> was created with unknown prop '${key}'`);
  });
  $$self.$$set = ($$props2) => {
    if ("id" in $$props2)
      $$invalidate(0, id = $$props2.id);
    if ("title" in $$props2)
      $$invalidate(1, title = $$props2.title);
    if ("altThumb" in $$props2)
      $$invalidate(2, altThumb = $$props2.altThumb);
    if ("play" in $$props2)
      $$invalidate(3, play = $$props2.play);
  };
  $$self.$capture_state = () => ({ id, title, altThumb, play });
  $$self.$inject_state = ($$props2) => {
    if ("id" in $$props2)
      $$invalidate(0, id = $$props2.id);
    if ("title" in $$props2)
      $$invalidate(1, title = $$props2.title);
    if ("altThumb" in $$props2)
      $$invalidate(2, altThumb = $$props2.altThumb);
    if ("play" in $$props2)
      $$invalidate(3, play = $$props2.play);
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  return [id, title, altThumb, play];
}
var Image = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance3, create_fragment3, safe_not_equal, { id: 0, title: 1, altThumb: 2, play: 3 }, add_css3);
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "Image",
      options,
      id: create_fragment3.name
    });
  }
  get id() {
    throw new Error("<Image>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set id(value) {
    throw new Error("<Image>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get title() {
    throw new Error("<Image>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set title(value) {
    throw new Error("<Image>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get altThumb() {
    throw new Error("<Image>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set altThumb(value) {
    throw new Error("<Image>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get play() {
    throw new Error("<Image>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set play(value) {
    throw new Error("<Image>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
};
var Image_default = Image;

// node_modules/svelte-youtube-embed/Youtube.svelte
var file4 = "node_modules/svelte-youtube-embed/Youtube.svelte";
function add_css4(target) {
  append_styles(target, "svelte-w0t24e", '.you__tube.svelte-w0t24e.svelte-w0t24e{position:relative;aspect-ratio:1.76991;overflow:hidden}.v__title.svelte-w0t24e.svelte-w0t24e{position:absolute;top:0;width:100%;background:linear-gradient(to bottom, hsla(0, 0%, 0%, 0.1), transparent);pointer-events:none}.v__title.svelte-w0t24e h3.svelte-w0t24e{font-family:var(\n      --title-font-family,\n      "Segoe UI",\n      Geneva,\n      Verdana,\n      sans-serif\n    );color:var(--title-color, #ffffff);padding:0 2ch;font-weight:400;text-shadow:0px 1px 3px var(--title-shadow-color, rgb(0, 0, 0, 0.2))}.b__overlay.svelte-w0t24e.svelte-w0t24e{position:absolute;top:0;left:0;width:100%;aspect-ratio:var(--aspect-ratio);cursor:pointer;transition:var(--overlay-transition, all 250ms ease-in-out)}.you__tube.svelte-w0t24e:hover .b__overlay.svelte-w0t24e{background:var(--overlay-bg-color, #00000030)}\n/*# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiWW91dHViZS5zdmVsdGUiLCJtYXBwaW5ncyI6IkFBc0RFLHNDQUFXLENBQ1QsUUFBUSxDQUFFLFFBQVEsQ0FDbEIsWUFBWSxDQUFFLE9BQU8sQ0FDckIsUUFBUSxDQUFFLE1BQ1osQ0FFQSxxQ0FBVSxDQUNSLFFBQVEsQ0FBRSxRQUFRLENBQ2xCLEdBQUcsQ0FBRSxDQUFDLENBQ04sS0FBSyxDQUFFLElBQUksQ0FDWCxVQUFVLENBQUUsZ0JBQWdCLEVBQUUsQ0FBQyxNQUFNLENBQUMsQ0FBQyxLQUFLLENBQUMsQ0FBQyxDQUFDLEVBQUUsQ0FBQyxDQUFDLEVBQUUsQ0FBQyxDQUFDLEdBQUcsQ0FBQyxDQUFDLENBQUMsV0FBVyxDQUFDLENBQ3pFLGNBQWMsQ0FBRSxJQUNsQixDQUNBLHVCQUFTLENBQUMsZ0JBQUcsQ0FDWCxXQUFXLENBQUU7QUFDakIsTUFBTSxtQkFBbUIsQ0FBQTtBQUN6QjtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUksQ0FBQyxDQUNELEtBQUssQ0FBRSxJQUFJLGFBQWEsQ0FBQyxRQUFRLENBQUMsQ0FDbEMsT0FBTyxDQUFFLENBQUMsQ0FBQyxHQUFHLENBQ2QsV0FBVyxDQUFFLEdBQUcsQ0FDaEIsV0FBVyxDQUFFLEdBQUcsQ0FBQyxHQUFHLENBQUMsR0FBRyxDQUFDLElBQUksb0JBQW9CLENBQUMsa0JBQWtCLENBQ3RFLENBQ0EsdUNBQVksQ0FDVixRQUFRLENBQUUsUUFBUSxDQUNsQixHQUFHLENBQUUsQ0FBQyxDQUNOLElBQUksQ0FBRSxDQUFDLENBQ1AsS0FBSyxDQUFFLElBQUksQ0FDWCxZQUFZLENBQUUsSUFBSSxjQUFjLENBQUMsQ0FDakMsTUFBTSxDQUFFLE9BQU8sQ0FDZixVQUFVLENBQUUsSUFBSSxvQkFBb0IsQ0FBQyxzQkFBc0IsQ0FDN0QsQ0FDQSx3QkFBVSxNQUFNLENBQUMseUJBQVksQ0FDM0IsVUFBVSxDQUFFLElBQUksa0JBQWtCLENBQUMsVUFBVSxDQUMvQyIsIm5hbWVzIjpbXSwic291cmNlcyI6WyJZb3V0dWJlLnN2ZWx0ZSJdfQ== */');
}
var get_thumbnail_slot_changes = (dirty) => ({});
var get_thumbnail_slot_context = (ctx) => ({});
function create_else_block2(ctx) {
  let current_block_type_index;
  let if_block;
  let t0;
  let div0;
  let t1;
  let div1;
  let h3;
  let t2;
  let current;
  let mounted;
  let dispose;
  const if_block_creators = [create_if_block_2, create_else_block_1];
  const if_blocks = [];
  function select_block_type_1(ctx2, dirty) {
    if (
      /*isCustomThumbnail*/
      ctx2[8]
    )
      return 0;
    return 1;
  }
  current_block_type_index = select_block_type_1(ctx, -1);
  if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
  const block = {
    c: function create() {
      if_block.c();
      t0 = space();
      div0 = element("div");
      t1 = space();
      div1 = element("div");
      h3 = element("h3");
      t2 = text(
        /*title*/
        ctx[3]
      );
      this.h();
    },
    l: function claim(nodes) {
      if_block.l(nodes);
      t0 = claim_space(nodes);
      div0 = claim_element(nodes, "DIV", { class: true });
      children(div0).forEach(detach_dev);
      t1 = claim_space(nodes);
      div1 = claim_element(nodes, "DIV", { class: true });
      var div1_nodes = children(div1);
      h3 = claim_element(div1_nodes, "H3", { class: true });
      var h3_nodes = children(h3);
      t2 = claim_text(
        h3_nodes,
        /*title*/
        ctx[3]
      );
      h3_nodes.forEach(detach_dev);
      div1_nodes.forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(div0, "class", "b__overlay svelte-w0t24e");
      add_location(div0, file4, 43, 4, 1025);
      attr_dev(h3, "class", "svelte-w0t24e");
      add_location(h3, file4, 44, 26, 1109);
      attr_dev(div1, "class", "v__title svelte-w0t24e");
      add_location(div1, file4, 44, 4, 1087);
    },
    m: function mount(target, anchor) {
      if_blocks[current_block_type_index].m(target, anchor);
      insert_hydration_dev(target, t0, anchor);
      insert_hydration_dev(target, div0, anchor);
      insert_hydration_dev(target, t1, anchor);
      insert_hydration_dev(target, div1, anchor);
      append_hydration_dev(div1, h3);
      append_hydration_dev(h3, t2);
      current = true;
      if (!mounted) {
        dispose = listen_dev(
          div0,
          "click",
          /*click_handler*/
          ctx[10],
          false,
          false,
          false,
          false
        );
        mounted = true;
      }
    },
    p: function update(ctx2, dirty) {
      if_block.p(ctx2, dirty);
      if (!current || dirty & /*title*/
      8)
        set_data_dev(
          t2,
          /*title*/
          ctx2[3]
        );
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(if_block);
      current = true;
    },
    o: function outro(local) {
      transition_out(if_block);
      current = false;
    },
    d: function destroy(detaching) {
      if_blocks[current_block_type_index].d(detaching);
      if (detaching)
        detach_dev(t0);
      if (detaching)
        detach_dev(div0);
      if (detaching)
        detach_dev(t1);
      if (detaching)
        detach_dev(div1);
      mounted = false;
      dispose();
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_else_block2.name,
    type: "else",
    source: "(38:2) {:else}",
    ctx
  });
  return block;
}
function create_if_block_1(ctx) {
  let iframe;
  let current;
  iframe = new Iframe_default({
    props: {
      play: (
        /*play*/
        ctx[6]
      ),
      id: (
        /*id*/
        ctx[0]
      ),
      title: (
        /*title*/
        ctx[3]
      ),
      animations: (
        /*animations*/
        ctx[2]
      )
    },
    $$inline: true
  });
  const block = {
    c: function create() {
      create_component(iframe.$$.fragment);
    },
    l: function claim(nodes) {
      claim_component(iframe.$$.fragment, nodes);
    },
    m: function mount(target, anchor) {
      mount_component(iframe, target, anchor);
      current = true;
    },
    p: function update(ctx2, dirty) {
      const iframe_changes = {};
      if (dirty & /*play*/
      64)
        iframe_changes.play = /*play*/
        ctx2[6];
      if (dirty & /*id*/
      1)
        iframe_changes.id = /*id*/
        ctx2[0];
      if (dirty & /*title*/
      8)
        iframe_changes.title = /*title*/
        ctx2[3];
      if (dirty & /*animations*/
      4)
        iframe_changes.animations = /*animations*/
        ctx2[2];
      iframe.$set(iframe_changes);
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(iframe.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(iframe.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      destroy_component(iframe, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block_1.name,
    type: "if",
    source: "(36:2) {#if play}",
    ctx
  });
  return block;
}
function create_else_block_1(ctx) {
  let image;
  let current;
  image = new Image_default({
    props: {
      id: (
        /*id*/
        ctx[0]
      ),
      title: (
        /*title*/
        ctx[3]
      ),
      altThumb: (
        /*altThumb*/
        ctx[1]
      ),
      play: (
        /*play*/
        ctx[6]
      )
    },
    $$inline: true
  });
  const block = {
    c: function create() {
      create_component(image.$$.fragment);
    },
    l: function claim(nodes) {
      claim_component(image.$$.fragment, nodes);
    },
    m: function mount(target, anchor) {
      mount_component(image, target, anchor);
      current = true;
    },
    p: function update(ctx2, dirty) {
      const image_changes = {};
      if (dirty & /*id*/
      1)
        image_changes.id = /*id*/
        ctx2[0];
      if (dirty & /*title*/
      8)
        image_changes.title = /*title*/
        ctx2[3];
      if (dirty & /*altThumb*/
      2)
        image_changes.altThumb = /*altThumb*/
        ctx2[1];
      if (dirty & /*play*/
      64)
        image_changes.play = /*play*/
        ctx2[6];
      image.$set(image_changes);
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(image.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(image.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      destroy_component(image, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_else_block_1.name,
    type: "else",
    source: "(41:4) {:else}",
    ctx
  });
  return block;
}
function create_if_block_2(ctx) {
  let current;
  const thumbnail_slot_template = (
    /*#slots*/
    ctx[9].thumbnail
  );
  const thumbnail_slot = create_slot(
    thumbnail_slot_template,
    ctx,
    /*$$scope*/
    ctx[12],
    get_thumbnail_slot_context
  );
  const block = {
    c: function create() {
      if (thumbnail_slot)
        thumbnail_slot.c();
    },
    l: function claim(nodes) {
      if (thumbnail_slot)
        thumbnail_slot.l(nodes);
    },
    m: function mount(target, anchor) {
      if (thumbnail_slot) {
        thumbnail_slot.m(target, anchor);
      }
      current = true;
    },
    p: function update(ctx2, dirty) {
      if (thumbnail_slot) {
        if (thumbnail_slot.p && (!current || dirty & /*$$scope*/
        4096)) {
          update_slot_base(
            thumbnail_slot,
            thumbnail_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[12],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[12]
            ) : get_slot_changes(
              thumbnail_slot_template,
              /*$$scope*/
              ctx2[12],
              dirty,
              get_thumbnail_slot_changes
            ),
            get_thumbnail_slot_context
          );
        }
      }
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(thumbnail_slot, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(thumbnail_slot, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (thumbnail_slot)
        thumbnail_slot.d(detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block_2.name,
    type: "if",
    source: "(39:4) {#if isCustomThumbnail}",
    ctx
  });
  return block;
}
function create_if_block2(ctx) {
  let button;
  let current;
  button = new Button_default({
    props: {
      isCustomPlayButton: (
        /*isCustomPlayButton*/
        ctx[7]
      ),
      $$slots: { default: [create_default_slot] },
      $$scope: { ctx }
    },
    $$inline: true
  });
  button.$on(
    "click",
    /*click_handler_1*/
    ctx[11]
  );
  const block = {
    c: function create() {
      create_component(button.$$.fragment);
    },
    l: function claim(nodes) {
      claim_component(button.$$.fragment, nodes);
    },
    m: function mount(target, anchor) {
      mount_component(button, target, anchor);
      current = true;
    },
    p: function update(ctx2, dirty) {
      const button_changes = {};
      if (dirty & /*$$scope*/
      4096) {
        button_changes.$$scope = { dirty, ctx: ctx2 };
      }
      button.$set(button_changes);
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(button.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(button.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      destroy_component(button, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block2.name,
    type: "if",
    source: "(47:2) {#if !play}",
    ctx
  });
  return block;
}
function create_default_slot(ctx) {
  let current;
  const default_slot_template = (
    /*#slots*/
    ctx[9].default
  );
  const default_slot = create_slot(
    default_slot_template,
    ctx,
    /*$$scope*/
    ctx[12],
    null
  );
  const block = {
    c: function create() {
      if (default_slot)
        default_slot.c();
    },
    l: function claim(nodes) {
      if (default_slot)
        default_slot.l(nodes);
    },
    m: function mount(target, anchor) {
      if (default_slot) {
        default_slot.m(target, anchor);
      }
      current = true;
    },
    p: function update(ctx2, dirty) {
      if (default_slot) {
        if (default_slot.p && (!current || dirty & /*$$scope*/
        4096)) {
          update_slot_base(
            default_slot,
            default_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[12],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[12]
            ) : get_slot_changes(
              default_slot_template,
              /*$$scope*/
              ctx2[12],
              dirty,
              null
            ),
            null
          );
        }
      }
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(default_slot, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(default_slot, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (default_slot)
        default_slot.d(detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_default_slot.name,
    type: "slot",
    source: "(48:4) <Button on:click={() => (play = true)} {isCustomPlayButton}>",
    ctx
  });
  return block;
}
function create_fragment4(ctx) {
  let div;
  let current_block_type_index;
  let if_block0;
  let t;
  let current;
  const if_block_creators = [create_if_block_1, create_else_block2];
  const if_blocks = [];
  function select_block_type(ctx2, dirty) {
    if (
      /*play*/
      ctx2[6]
    )
      return 0;
    return 1;
  }
  current_block_type_index = select_block_type(ctx, -1);
  if_block0 = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
  let if_block1 = !/*play*/
  ctx[6] && create_if_block2(ctx);
  const block = {
    c: function create() {
      div = element("div");
      if_block0.c();
      t = space();
      if (if_block1)
        if_block1.c();
      this.h();
    },
    l: function claim(nodes) {
      div = claim_element(nodes, "DIV", { class: true, style: true, title: true });
      var div_nodes = children(div);
      if_block0.l(div_nodes);
      t = claim_space(div_nodes);
      if (if_block1)
        if_block1.l(div_nodes);
      div_nodes.forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(div, "class", "you__tube svelte-w0t24e");
      set_style(
        div,
        "--aspect-ratio",
        /*width*/
        ctx[4] / /*height*/
        ctx[5] || "16/9"
      );
      attr_dev(
        div,
        "title",
        /*title*/
        ctx[3]
      );
      add_location(div, file4, 30, 0, 732);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, div, anchor);
      if_blocks[current_block_type_index].m(div, null);
      append_hydration_dev(div, t);
      if (if_block1)
        if_block1.m(div, null);
      current = true;
    },
    p: function update(ctx2, [dirty]) {
      let previous_block_index = current_block_type_index;
      current_block_type_index = select_block_type(ctx2, dirty);
      if (current_block_type_index === previous_block_index) {
        if_blocks[current_block_type_index].p(ctx2, dirty);
      } else {
        group_outros();
        transition_out(if_blocks[previous_block_index], 1, 1, () => {
          if_blocks[previous_block_index] = null;
        });
        check_outros();
        if_block0 = if_blocks[current_block_type_index];
        if (!if_block0) {
          if_block0 = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx2);
          if_block0.c();
        } else {
          if_block0.p(ctx2, dirty);
        }
        transition_in(if_block0, 1);
        if_block0.m(div, t);
      }
      if (!/*play*/
      ctx2[6]) {
        if (if_block1) {
          if_block1.p(ctx2, dirty);
          if (dirty & /*play*/
          64) {
            transition_in(if_block1, 1);
          }
        } else {
          if_block1 = create_if_block2(ctx2);
          if_block1.c();
          transition_in(if_block1, 1);
          if_block1.m(div, null);
        }
      } else if (if_block1) {
        group_outros();
        transition_out(if_block1, 1, 1, () => {
          if_block1 = null;
        });
        check_outros();
      }
      if (!current || dirty & /*width, height*/
      48) {
        set_style(
          div,
          "--aspect-ratio",
          /*width*/
          ctx2[4] / /*height*/
          ctx2[5] || "16/9"
        );
      }
      if (!current || dirty & /*title*/
      8) {
        attr_dev(
          div,
          "title",
          /*title*/
          ctx2[3]
        );
      }
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(if_block0);
      transition_in(if_block1);
      current = true;
    },
    o: function outro(local) {
      transition_out(if_block0);
      transition_out(if_block1);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching)
        detach_dev(div);
      if_blocks[current_block_type_index].d();
      if (if_block1)
        if_block1.d();
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment4.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance4($$self, $$props, $$invalidate) {
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("Youtube", slots, ["thumbnail", "default"]);
  const $$slots = compute_slots(slots);
  let { id = null } = $$props;
  let { altThumb = false } = $$props;
  let { animations = true } = $$props;
  let title = "";
  let width = 0;
  let height = 0;
  let videoInfo = {};
  onMount(async () => {
    const res = await fetch(`//www.youtube.com/oembed?url=https://www.youtube.com/watch?v=${id}&format=json`);
    videoInfo = await res.json();
    $$invalidate(3, title = videoInfo == null ? void 0 : videoInfo.title);
    $$invalidate(4, width = videoInfo == null ? void 0 : videoInfo.width);
    $$invalidate(5, height = videoInfo == null ? void 0 : videoInfo.height);
  });
  let play = false;
  const isCustomPlayButton = $$slots.default;
  const isCustomThumbnail = $$slots.thumbnail;
  const writable_props = ["id", "altThumb", "animations"];
  Object.keys($$props).forEach((key) => {
    if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$" && key !== "slot")
      console.warn(`<Youtube> was created with unknown prop '${key}'`);
  });
  const click_handler = () => $$invalidate(6, play = true);
  const click_handler_1 = () => $$invalidate(6, play = true);
  $$self.$$set = ($$props2) => {
    if ("id" in $$props2)
      $$invalidate(0, id = $$props2.id);
    if ("altThumb" in $$props2)
      $$invalidate(1, altThumb = $$props2.altThumb);
    if ("animations" in $$props2)
      $$invalidate(2, animations = $$props2.animations);
    if ("$$scope" in $$props2)
      $$invalidate(12, $$scope = $$props2.$$scope);
  };
  $$self.$capture_state = () => ({
    onMount,
    Button: Button_default,
    Iframe: Iframe_default,
    Image: Image_default,
    id,
    altThumb,
    animations,
    title,
    width,
    height,
    videoInfo,
    play,
    isCustomPlayButton,
    isCustomThumbnail
  });
  $$self.$inject_state = ($$props2) => {
    if ("id" in $$props2)
      $$invalidate(0, id = $$props2.id);
    if ("altThumb" in $$props2)
      $$invalidate(1, altThumb = $$props2.altThumb);
    if ("animations" in $$props2)
      $$invalidate(2, animations = $$props2.animations);
    if ("title" in $$props2)
      $$invalidate(3, title = $$props2.title);
    if ("width" in $$props2)
      $$invalidate(4, width = $$props2.width);
    if ("height" in $$props2)
      $$invalidate(5, height = $$props2.height);
    if ("videoInfo" in $$props2)
      videoInfo = $$props2.videoInfo;
    if ("play" in $$props2)
      $$invalidate(6, play = $$props2.play);
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  return [
    id,
    altThumb,
    animations,
    title,
    width,
    height,
    play,
    isCustomPlayButton,
    isCustomThumbnail,
    slots,
    click_handler,
    click_handler_1,
    $$scope
  ];
}
var Youtube = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance4, create_fragment4, safe_not_equal, { id: 0, altThumb: 1, animations: 2 }, add_css4);
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "Youtube",
      options,
      id: create_fragment4.name
    });
  }
  get id() {
    throw new Error("<Youtube>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set id(value) {
    throw new Error("<Youtube>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get altThumb() {
    throw new Error("<Youtube>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set altThumb(value) {
    throw new Error("<Youtube>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get animations() {
    throw new Error("<Youtube>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set animations(value) {
    throw new Error("<Youtube>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
};
var Youtube_default = Youtube;

// node_modules/svelte-youtube-embed/index.js
var svelte_youtube_embed_default = Youtube_default;
export {
  svelte_youtube_embed_default as default
};
//# sourceMappingURL=svelte-youtube-embed.js.map
