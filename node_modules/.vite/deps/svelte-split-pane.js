import "./chunk-6A2TAOKG.js";
import {
  SvelteComponentDev,
  add_location,
  append_hydration_dev,
  append_styles,
  attr_dev,
  binding_callbacks,
  children,
  claim_element,
  claim_space,
  claim_text,
  create_slot,
  detach_dev,
  dispatch_dev,
  element,
  get_all_dirty_from_scope,
  get_slot_changes,
  init,
  insert_hydration_dev,
  listen_dev,
  noop,
  onDestroy,
  onMount,
  run_all,
  safe_not_equal,
  set_style,
  space,
  text,
  transition_in,
  transition_out,
  update_slot_base,
  validate_slots
} from "./chunk-RVLVW3YK.js";
import "./chunk-UXIASGQL.js";

// node_modules/svelte-split-pane/src/HSplitPane.svelte
var file = "node_modules/svelte-split-pane/src/HSplitPane.svelte";
function add_css(target) {
  append_styles(target, "svelte-1lddsds", `div.wrapper.svelte-1lddsds{width:100%;height:100%;display:inline-flex}div.separator.svelte-1lddsds{cursor:col-resize;height:100%;width:4px;margin-left:-2px;z-index:1;background-color:#aaa;background-image:url("data:image/svg+xml;utf8,<svg xmlns='http://www.w3.org/2000/svg' width='10' height='30'><path d='M2 0 v30 M5 0 v30 M8 0 v30' fill='none' stroke='black'/></svg>");background-repeat:no-repeat;background-position:center}div.left.svelte-1lddsds{width:var(--left-panel-size);min-width:var(--min-left-panel-size);height:100%}div.right.svelte-1lddsds{width:var(--right-panel-size);min-width:var(--min-right-panel-size);height:100%}
/*# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiSFNwbGl0UGFuZS5zdmVsdGUiLCJtYXBwaW5ncyI6IkFBd0VJLEdBQUcsdUJBQVMsQ0FDUixLQUFLLENBQUUsSUFBSSxDQUNYLE1BQU0sQ0FBRSxJQUFJLENBRVosT0FBTyxDQUFFLFdBQ2IsQ0FDQSxHQUFHLHlCQUFXLENBQ1YsTUFBTSxDQUFFLFVBQVUsQ0FDbEIsTUFBTSxDQUFFLElBQUksQ0FDWixLQUFLLENBQUUsR0FBRyxDQUNWLFdBQVcsQ0FBRSxJQUFJLENBQ2pCLE9BQU8sQ0FBRSxDQUFDLENBQ1YsZ0JBQWdCLENBQUUsSUFBSSxDQUN0QixnQkFBZ0IsQ0FBRSxxS0FBcUssQ0FDdkwsaUJBQWlCLENBQUUsU0FBUyxDQUM1QixtQkFBbUIsQ0FBRSxNQUN6QixDQUNBLEdBQUcsb0JBQU0sQ0FDTCxLQUFLLENBQUUsSUFBSSxpQkFBaUIsQ0FBQyxDQUM3QixTQUFTLENBQUUsSUFBSSxxQkFBcUIsQ0FBQyxDQUNyQyxNQUFNLENBQUUsSUFDWixDQUNBLEdBQUcscUJBQU8sQ0FDTixLQUFLLENBQUUsSUFBSSxrQkFBa0IsQ0FBQyxDQUM5QixTQUFTLENBQUUsSUFBSSxzQkFBc0IsQ0FBQyxDQUN0QyxNQUFNLENBQUUsSUFDWiIsIm5hbWVzIjpbXSwic291cmNlcyI6WyJIU3BsaXRQYW5lLnN2ZWx0ZSJdfQ== */`);
}
var get_right_slot_changes = (dirty) => ({});
var get_right_slot_context = (ctx) => ({});
var get_left_slot_changes = (dirty) => ({});
var get_left_slot_context = (ctx) => ({});
function fallback_block_1(ctx) {
  let div;
  let t;
  const block = {
    c: function create() {
      div = element("div");
      t = text("Left Contents goes here...");
      this.h();
    },
    l: function claim(nodes) {
      div = claim_element(nodes, "DIV", { style: true });
      var div_nodes = children(div);
      t = claim_text(div_nodes, "Left Contents goes here...");
      div_nodes.forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      set_style(div, "background-color", "red");
      add_location(div, file, 104, 12, 3590);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, div, anchor);
      append_hydration_dev(div, t);
    },
    p: noop,
    d: function destroy(detaching) {
      if (detaching)
        detach_dev(div);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: fallback_block_1.name,
    type: "fallback",
    source: "(104:26)               ",
    ctx
  });
  return block;
}
function fallback_block(ctx) {
  let div;
  let t;
  const block = {
    c: function create() {
      div = element("div");
      t = text("Right Contents goes here...");
      this.h();
    },
    l: function claim(nodes) {
      div = claim_element(nodes, "DIV", { style: true });
      var div_nodes = children(div);
      t = claim_text(div_nodes, "Right Contents goes here...");
      div_nodes.forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      set_style(div, "background-color", "yellow");
      add_location(div, file, 113, 12, 3923);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, div, anchor);
      append_hydration_dev(div, t);
    },
    p: noop,
    d: function destroy(detaching) {
      if (detaching)
        detach_dev(div);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: fallback_block.name,
    type: "fallback",
    source: "(113:27)               ",
    ctx
  });
  return block;
}
function create_fragment(ctx) {
  let div3;
  let div0;
  let t0;
  let div1;
  let t1;
  let div2;
  let current;
  let mounted;
  let dispose;
  const left_slot_template = (
    /*#slots*/
    ctx[10].left
  );
  const left_slot = create_slot(
    left_slot_template,
    ctx,
    /*$$scope*/
    ctx[9],
    get_left_slot_context
  );
  const left_slot_or_fallback = left_slot || fallback_block_1(ctx);
  const right_slot_template = (
    /*#slots*/
    ctx[10].right
  );
  const right_slot = create_slot(
    right_slot_template,
    ctx,
    /*$$scope*/
    ctx[9],
    get_right_slot_context
  );
  const right_slot_or_fallback = right_slot || fallback_block(ctx);
  const block = {
    c: function create() {
      div3 = element("div");
      div0 = element("div");
      if (left_slot_or_fallback)
        left_slot_or_fallback.c();
      t0 = space();
      div1 = element("div");
      t1 = space();
      div2 = element("div");
      if (right_slot_or_fallback)
        right_slot_or_fallback.c();
      this.h();
    },
    l: function claim(nodes) {
      div3 = claim_element(nodes, "DIV", { class: true, style: true });
      var div3_nodes = children(div3);
      div0 = claim_element(div3_nodes, "DIV", { class: true });
      var div0_nodes = children(div0);
      if (left_slot_or_fallback)
        left_slot_or_fallback.l(div0_nodes);
      div0_nodes.forEach(detach_dev);
      t0 = claim_space(div3_nodes);
      div1 = claim_element(div3_nodes, "DIV", { class: true });
      var div1_nodes = children(div1);
      div1_nodes.forEach(detach_dev);
      t1 = claim_space(div3_nodes);
      div2 = claim_element(div3_nodes, "DIV", { class: true });
      var div2_nodes = children(div2);
      if (right_slot_or_fallback)
        right_slot_or_fallback.l(div2_nodes);
      div2_nodes.forEach(detach_dev);
      div3_nodes.forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(div0, "class", "left svelte-1lddsds");
      add_location(div0, file, 102, 4, 3513);
      attr_dev(div1, "class", "separator svelte-1lddsds");
      add_location(div1, file, 109, 4, 3725);
      attr_dev(div2, "class", "right svelte-1lddsds");
      add_location(div2, file, 111, 4, 3843);
      attr_dev(div3, "class", "wrapper svelte-1lddsds");
      set_style(
        div3,
        "--left-panel-size",
        /*leftPaneSize*/
        ctx[0]
      );
      set_style(
        div3,
        "--right-panel-size",
        /*rightPaneSize*/
        ctx[1]
      );
      set_style(
        div3,
        "--min-left-panel-size",
        /*minLeftPaneSize*/
        ctx[2]
      );
      set_style(
        div3,
        "--min-right-panel-size",
        /*minRightPaneSize*/
        ctx[3]
      );
      add_location(div3, file, 101, 0, 3320);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, div3, anchor);
      append_hydration_dev(div3, div0);
      if (left_slot_or_fallback) {
        left_slot_or_fallback.m(div0, null);
      }
      ctx[11](div0);
      append_hydration_dev(div3, t0);
      append_hydration_dev(div3, div1);
      ctx[12](div1);
      append_hydration_dev(div3, t1);
      append_hydration_dev(div3, div2);
      if (right_slot_or_fallback) {
        right_slot_or_fallback.m(div2, null);
      }
      ctx[13](div2);
      current = true;
      if (!mounted) {
        dispose = [
          listen_dev(
            div1,
            "mousedown",
            /*onMouseDown*/
            ctx[7],
            false,
            false,
            false,
            false
          ),
          listen_dev(
            div1,
            "touchstart",
            /*onMouseDown*/
            ctx[7],
            false,
            false,
            false,
            false
          )
        ];
        mounted = true;
      }
    },
    p: function update(ctx2, [dirty]) {
      if (left_slot) {
        if (left_slot.p && (!current || dirty & /*$$scope*/
        512)) {
          update_slot_base(
            left_slot,
            left_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[9],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[9]
            ) : get_slot_changes(
              left_slot_template,
              /*$$scope*/
              ctx2[9],
              dirty,
              get_left_slot_changes
            ),
            get_left_slot_context
          );
        }
      }
      if (right_slot) {
        if (right_slot.p && (!current || dirty & /*$$scope*/
        512)) {
          update_slot_base(
            right_slot,
            right_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[9],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[9]
            ) : get_slot_changes(
              right_slot_template,
              /*$$scope*/
              ctx2[9],
              dirty,
              get_right_slot_changes
            ),
            get_right_slot_context
          );
        }
      }
      if (!current || dirty & /*leftPaneSize*/
      1) {
        set_style(
          div3,
          "--left-panel-size",
          /*leftPaneSize*/
          ctx2[0]
        );
      }
      if (!current || dirty & /*rightPaneSize*/
      2) {
        set_style(
          div3,
          "--right-panel-size",
          /*rightPaneSize*/
          ctx2[1]
        );
      }
      if (!current || dirty & /*minLeftPaneSize*/
      4) {
        set_style(
          div3,
          "--min-left-panel-size",
          /*minLeftPaneSize*/
          ctx2[2]
        );
      }
      if (!current || dirty & /*minRightPaneSize*/
      8) {
        set_style(
          div3,
          "--min-right-panel-size",
          /*minRightPaneSize*/
          ctx2[3]
        );
      }
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(left_slot_or_fallback, local);
      transition_in(right_slot_or_fallback, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(left_slot_or_fallback, local);
      transition_out(right_slot_or_fallback, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching)
        detach_dev(div3);
      if (left_slot_or_fallback)
        left_slot_or_fallback.d(detaching);
      ctx[11](null);
      ctx[12](null);
      if (right_slot_or_fallback)
        right_slot_or_fallback.d(detaching);
      ctx[13](null);
      mounted = false;
      run_all(dispose);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance($$self, $$props, $$invalidate) {
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("HSplitPane", slots, ["left", "right"]);
  let separator;
  let { updateCallback = () => {
    return;
  } } = $$props;
  let md;
  const onMouseDown = (e) => {
    e.preventDefault();
    if (e.button !== 0)
      return;
    md = {
      e,
      offsetLeft: separator.offsetLeft,
      offsetTop: separator.offsetTop,
      firstWidth: left.offsetWidth,
      secondWidth: right.offsetWidth
    };
    window.addEventListener("mousemove", onMouseMove);
    window.addEventListener("mouseup", onMouseUp);
    window.addEventListener("touchmove", onMouseMove);
    window.addEventListener("touchend", onMouseUp);
  };
  const onMouseMove = (e) => {
    e.preventDefault();
    if (e.button !== 0)
      return;
    var delta = {
      x: e.clientX - md.e.clientX,
      y: e.clientY - md.e.clientY
    };
    delta.x = Math.min(Math.max(delta.x, -md.firstWidth), md.secondWidth);
    $$invalidate(4, separator.style.left = md.offsetLeft + delta.x + "px", separator);
    $$invalidate(5, left.style.width = md.firstWidth + delta.x + "px", left);
    $$invalidate(6, right.style.width = md.secondWidth - delta.x + "px", right);
    updateCallback();
  };
  const onMouseUp = (e) => {
    if (e) {
      e.preventDefault();
      if (e.button !== 0)
        return;
    }
    updateCallback();
    window.removeEventListener("mousemove", onMouseMove);
    window.removeEventListener("mouseup", onMouseUp);
    window.removeEventListener("touchmove", onMouseMove);
    window.removeEventListener("touchend", onMouseUp);
  };
  function resetSize() {
    if (left)
      left.removeAttribute("style");
    if (right)
      right.removeAttribute("style");
    if (separator)
      separator.removeAttribute("style");
  }
  function onResize() {
    onMouseUp();
    resetSize();
  }
  onMount(() => {
    window.addEventListener("resize", onResize);
  });
  onDestroy(() => {
    window.removeEventListener("resize", onResize);
  });
  let left, right;
  let { leftPaneSize = "50%" } = $$props;
  let { rightPaneSize = "50%" } = $$props;
  let { minLeftPaneSize = "0" } = $$props;
  let { minRightPaneSize = "0" } = $$props;
  const writable_props = [
    "updateCallback",
    "leftPaneSize",
    "rightPaneSize",
    "minLeftPaneSize",
    "minRightPaneSize"
  ];
  Object.keys($$props).forEach((key) => {
    if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$" && key !== "slot")
      console.warn(`<HSplitPane> was created with unknown prop '${key}'`);
  });
  function div0_binding($$value) {
    binding_callbacks[$$value ? "unshift" : "push"](() => {
      left = $$value;
      $$invalidate(5, left);
    });
  }
  function div1_binding($$value) {
    binding_callbacks[$$value ? "unshift" : "push"](() => {
      separator = $$value;
      $$invalidate(4, separator);
    });
  }
  function div2_binding($$value) {
    binding_callbacks[$$value ? "unshift" : "push"](() => {
      right = $$value;
      $$invalidate(6, right);
    });
  }
  $$self.$$set = ($$props2) => {
    if ("updateCallback" in $$props2)
      $$invalidate(8, updateCallback = $$props2.updateCallback);
    if ("leftPaneSize" in $$props2)
      $$invalidate(0, leftPaneSize = $$props2.leftPaneSize);
    if ("rightPaneSize" in $$props2)
      $$invalidate(1, rightPaneSize = $$props2.rightPaneSize);
    if ("minLeftPaneSize" in $$props2)
      $$invalidate(2, minLeftPaneSize = $$props2.minLeftPaneSize);
    if ("minRightPaneSize" in $$props2)
      $$invalidate(3, minRightPaneSize = $$props2.minRightPaneSize);
    if ("$$scope" in $$props2)
      $$invalidate(9, $$scope = $$props2.$$scope);
  };
  $$self.$capture_state = () => ({
    onMount,
    onDestroy,
    separator,
    updateCallback,
    md,
    onMouseDown,
    onMouseMove,
    onMouseUp,
    resetSize,
    onResize,
    left,
    right,
    leftPaneSize,
    rightPaneSize,
    minLeftPaneSize,
    minRightPaneSize
  });
  $$self.$inject_state = ($$props2) => {
    if ("separator" in $$props2)
      $$invalidate(4, separator = $$props2.separator);
    if ("updateCallback" in $$props2)
      $$invalidate(8, updateCallback = $$props2.updateCallback);
    if ("md" in $$props2)
      md = $$props2.md;
    if ("left" in $$props2)
      $$invalidate(5, left = $$props2.left);
    if ("right" in $$props2)
      $$invalidate(6, right = $$props2.right);
    if ("leftPaneSize" in $$props2)
      $$invalidate(0, leftPaneSize = $$props2.leftPaneSize);
    if ("rightPaneSize" in $$props2)
      $$invalidate(1, rightPaneSize = $$props2.rightPaneSize);
    if ("minLeftPaneSize" in $$props2)
      $$invalidate(2, minLeftPaneSize = $$props2.minLeftPaneSize);
    if ("minRightPaneSize" in $$props2)
      $$invalidate(3, minRightPaneSize = $$props2.minRightPaneSize);
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  $$self.$$.update = () => {
    if ($$self.$$.dirty & /*leftPaneSize*/
    1) {
      $:
        leftPaneSize && resetSize();
    }
    if ($$self.$$.dirty & /*rightPaneSize*/
    2) {
      $:
        rightPaneSize && resetSize();
    }
  };
  return [
    leftPaneSize,
    rightPaneSize,
    minLeftPaneSize,
    minRightPaneSize,
    separator,
    left,
    right,
    onMouseDown,
    updateCallback,
    $$scope,
    slots,
    div0_binding,
    div1_binding,
    div2_binding
  ];
}
var HSplitPane = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(
      this,
      options,
      instance,
      create_fragment,
      safe_not_equal,
      {
        updateCallback: 8,
        leftPaneSize: 0,
        rightPaneSize: 1,
        minLeftPaneSize: 2,
        minRightPaneSize: 3
      },
      add_css
    );
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "HSplitPane",
      options,
      id: create_fragment.name
    });
  }
  get updateCallback() {
    throw new Error("<HSplitPane>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set updateCallback(value) {
    throw new Error("<HSplitPane>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get leftPaneSize() {
    throw new Error("<HSplitPane>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set leftPaneSize(value) {
    throw new Error("<HSplitPane>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get rightPaneSize() {
    throw new Error("<HSplitPane>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set rightPaneSize(value) {
    throw new Error("<HSplitPane>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get minLeftPaneSize() {
    throw new Error("<HSplitPane>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set minLeftPaneSize(value) {
    throw new Error("<HSplitPane>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get minRightPaneSize() {
    throw new Error("<HSplitPane>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set minRightPaneSize(value) {
    throw new Error("<HSplitPane>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
};
var HSplitPane_default = HSplitPane;

// node_modules/svelte-split-pane/src/VSplitPane.svelte
var file2 = "node_modules/svelte-split-pane/src/VSplitPane.svelte";
function add_css2(target) {
  append_styles(target, "svelte-1uzebfl", "div.wrapper.svelte-1uzebfl{width:100%;height:100%;display:flex;flex-direction:column}div.separator.svelte-1uzebfl{cursor:row-resize;width:100%;height:4px;margin-top:-2px;z-index:1;background-color:#aaa}div.top.svelte-1uzebfl{height:var(--top-panel-size);min-height:var(--min-top-panel-size);width:100%}div.down.svelte-1uzebfl{height:var(--down-panel-size);min-height:var(--min-down-panel-size);width:100%}\n/*# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiVlNwbGl0UGFuZS5zdmVsdGUiLCJtYXBwaW5ncyI6IkFBeUVJLEdBQUcsdUJBQVMsQ0FDUixLQUFLLENBQUUsSUFBSSxDQUNYLE1BQU0sQ0FBRSxJQUFJLENBRVosT0FBTyxDQUFFLElBQUksQ0FDYixjQUFjLENBQUUsTUFDcEIsQ0FDQSxHQUFHLHlCQUFXLENBQ1YsTUFBTSxDQUFFLFVBQVUsQ0FDbEIsS0FBSyxDQUFFLElBQUksQ0FDWCxNQUFNLENBQUUsR0FBRyxDQUNYLFVBQVUsQ0FBRSxJQUFJLENBQ2hCLE9BQU8sQ0FBRSxDQUFDLENBQ1YsZ0JBQWdCLENBQUUsSUFDdEIsQ0FDQSxHQUFHLG1CQUFLLENBQ0osTUFBTSxDQUFFLElBQUksZ0JBQWdCLENBQUMsQ0FDN0IsVUFBVSxDQUFFLElBQUksb0JBQW9CLENBQUMsQ0FDckMsS0FBSyxDQUFFLElBQ1gsQ0FDQSxHQUFHLG9CQUFNLENBQ0wsTUFBTSxDQUFFLElBQUksaUJBQWlCLENBQUMsQ0FDOUIsVUFBVSxDQUFFLElBQUkscUJBQXFCLENBQUMsQ0FDdEMsS0FBSyxDQUFFLElBQ1giLCJuYW1lcyI6W10sInNvdXJjZXMiOlsiVlNwbGl0UGFuZS5zdmVsdGUiXX0= */");
}
var get_down_slot_changes = (dirty) => ({});
var get_down_slot_context = (ctx) => ({});
var get_top_slot_changes = (dirty) => ({});
var get_top_slot_context = (ctx) => ({});
function fallback_block_12(ctx) {
  let div;
  let t;
  const block = {
    c: function create() {
      div = element("div");
      t = text("Top Contents goes here...");
      this.h();
    },
    l: function claim(nodes) {
      div = claim_element(nodes, "DIV", { style: true });
      var div_nodes = children(div);
      t = claim_text(div_nodes, "Top Contents goes here...");
      div_nodes.forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      set_style(div, "background-color", "red");
      add_location(div, file2, 103, 12, 3329);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, div, anchor);
      append_hydration_dev(div, t);
    },
    p: noop,
    d: function destroy(detaching) {
      if (detaching)
        detach_dev(div);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: fallback_block_12.name,
    type: "fallback",
    source: "(103:25)               ",
    ctx
  });
  return block;
}
function fallback_block2(ctx) {
  let div;
  let t;
  const block = {
    c: function create() {
      div = element("div");
      t = text("Down Contents goes here...");
      this.h();
    },
    l: function claim(nodes) {
      div = claim_element(nodes, "DIV", { style: true });
      var div_nodes = children(div);
      t = claim_text(div_nodes, "Down Contents goes here...");
      div_nodes.forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      set_style(div, "background-color", "yellow");
      add_location(div, file2, 112, 12, 3658);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, div, anchor);
      append_hydration_dev(div, t);
    },
    p: noop,
    d: function destroy(detaching) {
      if (detaching)
        detach_dev(div);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: fallback_block2.name,
    type: "fallback",
    source: "(112:26)               ",
    ctx
  });
  return block;
}
function create_fragment2(ctx) {
  let div3;
  let div0;
  let t0;
  let div1;
  let t1;
  let div2;
  let current;
  let mounted;
  let dispose;
  const top_slot_template = (
    /*#slots*/
    ctx[10].top
  );
  const top_slot = create_slot(
    top_slot_template,
    ctx,
    /*$$scope*/
    ctx[9],
    get_top_slot_context
  );
  const top_slot_or_fallback = top_slot || fallback_block_12(ctx);
  const down_slot_template = (
    /*#slots*/
    ctx[10].down
  );
  const down_slot = create_slot(
    down_slot_template,
    ctx,
    /*$$scope*/
    ctx[9],
    get_down_slot_context
  );
  const down_slot_or_fallback = down_slot || fallback_block2(ctx);
  const block = {
    c: function create() {
      div3 = element("div");
      div0 = element("div");
      if (top_slot_or_fallback)
        top_slot_or_fallback.c();
      t0 = space();
      div1 = element("div");
      t1 = space();
      div2 = element("div");
      if (down_slot_or_fallback)
        down_slot_or_fallback.c();
      this.h();
    },
    l: function claim(nodes) {
      div3 = claim_element(nodes, "DIV", { class: true, style: true });
      var div3_nodes = children(div3);
      div0 = claim_element(div3_nodes, "DIV", { class: true });
      var div0_nodes = children(div0);
      if (top_slot_or_fallback)
        top_slot_or_fallback.l(div0_nodes);
      div0_nodes.forEach(detach_dev);
      t0 = claim_space(div3_nodes);
      div1 = claim_element(div3_nodes, "DIV", { class: true });
      var div1_nodes = children(div1);
      div1_nodes.forEach(detach_dev);
      t1 = claim_space(div3_nodes);
      div2 = claim_element(div3_nodes, "DIV", { class: true });
      var div2_nodes = children(div2);
      if (down_slot_or_fallback)
        down_slot_or_fallback.l(div2_nodes);
      div2_nodes.forEach(detach_dev);
      div3_nodes.forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(div0, "class", "top svelte-1uzebfl");
      add_location(div0, file2, 101, 4, 3255);
      attr_dev(div1, "class", "separator svelte-1uzebfl");
      add_location(div1, file2, 108, 4, 3463);
      attr_dev(div2, "class", "down svelte-1uzebfl");
      add_location(div2, file2, 110, 4, 3581);
      attr_dev(div3, "class", "wrapper svelte-1uzebfl");
      set_style(
        div3,
        "--top-panel-size",
        /*topPanelSize*/
        ctx[0]
      );
      set_style(
        div3,
        "--down-panel-size",
        /*downPanelSize*/
        ctx[1]
      );
      set_style(
        div3,
        "--min-top-panel-size",
        /*minTopPaneSize*/
        ctx[2]
      );
      set_style(
        div3,
        "--min-down-panel-size",
        /*minDownPaneSize*/
        ctx[3]
      );
      add_location(div3, file2, 100, 0, 3069);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, div3, anchor);
      append_hydration_dev(div3, div0);
      if (top_slot_or_fallback) {
        top_slot_or_fallback.m(div0, null);
      }
      ctx[11](div0);
      append_hydration_dev(div3, t0);
      append_hydration_dev(div3, div1);
      ctx[12](div1);
      append_hydration_dev(div3, t1);
      append_hydration_dev(div3, div2);
      if (down_slot_or_fallback) {
        down_slot_or_fallback.m(div2, null);
      }
      ctx[13](div2);
      current = true;
      if (!mounted) {
        dispose = [
          listen_dev(
            div1,
            "mousedown",
            /*onMouseDown*/
            ctx[7],
            false,
            false,
            false,
            false
          ),
          listen_dev(
            div1,
            "touchstart",
            /*onMouseDown*/
            ctx[7],
            false,
            false,
            false,
            false
          )
        ];
        mounted = true;
      }
    },
    p: function update(ctx2, [dirty]) {
      if (top_slot) {
        if (top_slot.p && (!current || dirty & /*$$scope*/
        512)) {
          update_slot_base(
            top_slot,
            top_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[9],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[9]
            ) : get_slot_changes(
              top_slot_template,
              /*$$scope*/
              ctx2[9],
              dirty,
              get_top_slot_changes
            ),
            get_top_slot_context
          );
        }
      }
      if (down_slot) {
        if (down_slot.p && (!current || dirty & /*$$scope*/
        512)) {
          update_slot_base(
            down_slot,
            down_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[9],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[9]
            ) : get_slot_changes(
              down_slot_template,
              /*$$scope*/
              ctx2[9],
              dirty,
              get_down_slot_changes
            ),
            get_down_slot_context
          );
        }
      }
      if (!current || dirty & /*topPanelSize*/
      1) {
        set_style(
          div3,
          "--top-panel-size",
          /*topPanelSize*/
          ctx2[0]
        );
      }
      if (!current || dirty & /*downPanelSize*/
      2) {
        set_style(
          div3,
          "--down-panel-size",
          /*downPanelSize*/
          ctx2[1]
        );
      }
      if (!current || dirty & /*minTopPaneSize*/
      4) {
        set_style(
          div3,
          "--min-top-panel-size",
          /*minTopPaneSize*/
          ctx2[2]
        );
      }
      if (!current || dirty & /*minDownPaneSize*/
      8) {
        set_style(
          div3,
          "--min-down-panel-size",
          /*minDownPaneSize*/
          ctx2[3]
        );
      }
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(top_slot_or_fallback, local);
      transition_in(down_slot_or_fallback, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(top_slot_or_fallback, local);
      transition_out(down_slot_or_fallback, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching)
        detach_dev(div3);
      if (top_slot_or_fallback)
        top_slot_or_fallback.d(detaching);
      ctx[11](null);
      ctx[12](null);
      if (down_slot_or_fallback)
        down_slot_or_fallback.d(detaching);
      ctx[13](null);
      mounted = false;
      run_all(dispose);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment2.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance2($$self, $$props, $$invalidate) {
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("VSplitPane", slots, ["top", "down"]);
  let separator;
  let { updateCallback = () => {
    return;
  } } = $$props;
  let md;
  const onMouseDown = (e) => {
    e.preventDefault();
    if (e.button !== 0)
      return;
    md = {
      e,
      offsetLeft: separator.offsetLeft,
      offsetTop: separator.offsetTop,
      firstHeight: top.offsetHeight,
      secondHeight: down.offsetHeight
    };
    window.addEventListener("mousemove", onMouseMove);
    window.addEventListener("mouseup", onMouseUp);
    window.addEventListener("touchmove", onMouseMove);
    window.addEventListener("touchend", onMouseUp);
  };
  const onMouseMove = (e) => {
    e.preventDefault();
    if (e.button !== 0)
      return;
    var delta = {
      x: e.clientX - md.e.clientX,
      y: e.clientY - md.e.clientY
    };
    delta.y = Math.min(Math.max(delta.y, -md.firstHeight), md.secondHeight);
    $$invalidate(4, separator.style.top = md.offsetTop + delta.y + "px", separator);
    $$invalidate(5, top.style.height = md.firstHeight + delta.y + "px", top);
    $$invalidate(6, down.style.height = md.secondHeight - delta.y + "px", down);
    updateCallback();
  };
  const onMouseUp = (e) => {
    if (e) {
      e.preventDefault();
      if (e.button !== 0)
        return;
    }
    updateCallback();
    window.removeEventListener("mousemove", onMouseMove);
    window.removeEventListener("mouseup", onMouseUp);
    window.removeEventListener("touchmove", onMouseMove);
    window.removeEventListener("touchend", onMouseUp);
  };
  function resetSize() {
    if (top)
      top.removeAttribute("style");
    if (down)
      down.removeAttribute("style");
    if (separator)
      separator.removeAttribute("style");
  }
  function onResize() {
    onMouseUp();
    resetSize();
  }
  onMount(() => {
    window.addEventListener("resize", onResize);
  });
  onDestroy(() => {
    window.removeEventListener("resize", onResize);
  });
  let top, down;
  let { topPanelSize = "50%" } = $$props;
  let { downPanelSize = "50%" } = $$props;
  let { minTopPaneSize = "0" } = $$props;
  let { minDownPaneSize = "0" } = $$props;
  const writable_props = [
    "updateCallback",
    "topPanelSize",
    "downPanelSize",
    "minTopPaneSize",
    "minDownPaneSize"
  ];
  Object.keys($$props).forEach((key) => {
    if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$" && key !== "slot")
      console.warn(`<VSplitPane> was created with unknown prop '${key}'`);
  });
  function div0_binding($$value) {
    binding_callbacks[$$value ? "unshift" : "push"](() => {
      top = $$value;
      $$invalidate(5, top);
    });
  }
  function div1_binding($$value) {
    binding_callbacks[$$value ? "unshift" : "push"](() => {
      separator = $$value;
      $$invalidate(4, separator);
    });
  }
  function div2_binding($$value) {
    binding_callbacks[$$value ? "unshift" : "push"](() => {
      down = $$value;
      $$invalidate(6, down);
    });
  }
  $$self.$$set = ($$props2) => {
    if ("updateCallback" in $$props2)
      $$invalidate(8, updateCallback = $$props2.updateCallback);
    if ("topPanelSize" in $$props2)
      $$invalidate(0, topPanelSize = $$props2.topPanelSize);
    if ("downPanelSize" in $$props2)
      $$invalidate(1, downPanelSize = $$props2.downPanelSize);
    if ("minTopPaneSize" in $$props2)
      $$invalidate(2, minTopPaneSize = $$props2.minTopPaneSize);
    if ("minDownPaneSize" in $$props2)
      $$invalidate(3, minDownPaneSize = $$props2.minDownPaneSize);
    if ("$$scope" in $$props2)
      $$invalidate(9, $$scope = $$props2.$$scope);
  };
  $$self.$capture_state = () => ({
    onMount,
    onDestroy,
    separator,
    updateCallback,
    md,
    onMouseDown,
    onMouseMove,
    onMouseUp,
    resetSize,
    onResize,
    top,
    down,
    topPanelSize,
    downPanelSize,
    minTopPaneSize,
    minDownPaneSize
  });
  $$self.$inject_state = ($$props2) => {
    if ("separator" in $$props2)
      $$invalidate(4, separator = $$props2.separator);
    if ("updateCallback" in $$props2)
      $$invalidate(8, updateCallback = $$props2.updateCallback);
    if ("md" in $$props2)
      md = $$props2.md;
    if ("top" in $$props2)
      $$invalidate(5, top = $$props2.top);
    if ("down" in $$props2)
      $$invalidate(6, down = $$props2.down);
    if ("topPanelSize" in $$props2)
      $$invalidate(0, topPanelSize = $$props2.topPanelSize);
    if ("downPanelSize" in $$props2)
      $$invalidate(1, downPanelSize = $$props2.downPanelSize);
    if ("minTopPaneSize" in $$props2)
      $$invalidate(2, minTopPaneSize = $$props2.minTopPaneSize);
    if ("minDownPaneSize" in $$props2)
      $$invalidate(3, minDownPaneSize = $$props2.minDownPaneSize);
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  $$self.$$.update = () => {
    if ($$self.$$.dirty & /*topPanelSize*/
    1) {
      $:
        topPanelSize && resetSize();
    }
    if ($$self.$$.dirty & /*downPanelSize*/
    2) {
      $:
        downPanelSize && resetSize();
    }
  };
  return [
    topPanelSize,
    downPanelSize,
    minTopPaneSize,
    minDownPaneSize,
    separator,
    top,
    down,
    onMouseDown,
    updateCallback,
    $$scope,
    slots,
    div0_binding,
    div1_binding,
    div2_binding
  ];
}
var VSplitPane = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(
      this,
      options,
      instance2,
      create_fragment2,
      safe_not_equal,
      {
        updateCallback: 8,
        topPanelSize: 0,
        downPanelSize: 1,
        minTopPaneSize: 2,
        minDownPaneSize: 3
      },
      add_css2
    );
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "VSplitPane",
      options,
      id: create_fragment2.name
    });
  }
  get updateCallback() {
    throw new Error("<VSplitPane>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set updateCallback(value) {
    throw new Error("<VSplitPane>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get topPanelSize() {
    throw new Error("<VSplitPane>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set topPanelSize(value) {
    throw new Error("<VSplitPane>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get downPanelSize() {
    throw new Error("<VSplitPane>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set downPanelSize(value) {
    throw new Error("<VSplitPane>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get minTopPaneSize() {
    throw new Error("<VSplitPane>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set minTopPaneSize(value) {
    throw new Error("<VSplitPane>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get minDownPaneSize() {
    throw new Error("<VSplitPane>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set minDownPaneSize(value) {
    throw new Error("<VSplitPane>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
};
var VSplitPane_default = VSplitPane;
export {
  HSplitPane_default as HSplitPane,
  VSplitPane_default as VSplitPane
};
//# sourceMappingURL=svelte-split-pane.js.map
