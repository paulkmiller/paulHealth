import {
  require_lodash
} from "./chunk-343ACIYX.js";
import {
  require_lodash as require_lodash2
} from "./chunk-TWDEUQP3.js";
import {
  require_lodash as require_lodash3
} from "./chunk-U4NGFETE.js";
import {
  __toESM
} from "./chunk-UXIASGQL.js";

// node_modules/easy-reactive/src/simply-reactive.js
var import_lodash2 = __toESM(require_lodash(), 1);
var import_lodash3 = __toESM(require_lodash3(), 1);

// node_modules/easy-reactive/src/utils/object.js
var import_lodash = __toESM(require_lodash2(), 1);
var depsAreEqual = (deps1, deps2) => {
  return (0, import_lodash.default)(deps1, deps2);
};
var getDepNames = (deps) => {
  return Object.keys(deps || {});
};
var getUpdatedDeps = (depNames, currentData) => {
  const updatedDeps = {};
  depNames.forEach((depName) => {
    updatedDeps[depName] = currentData[depName];
  });
  return updatedDeps;
};

// node_modules/easy-reactive/src/utils/subscription.js
var createSubscription = () => {
  const subscribers = {};
  const memoDependency = (target, dep) => {
    const { watcherName, fn } = target;
    const { prop, value } = dep;
    if (!subscribers[watcherName]) {
      subscribers[watcherName] = {
        deps: {},
        fn
      };
    }
    subscribers[watcherName].deps[prop] = value;
  };
  return {
    subscribers,
    subscribe(target, dep) {
      if (target) {
        memoDependency(target, dep);
      }
    },
    notify(data, prop) {
      Object.entries(subscribers).forEach(([watchName, { deps, fn }]) => {
        const depNames = getDepNames(deps);
        if (depNames.includes(prop)) {
          const updatedDeps = getUpdatedDeps(depNames, data);
          if (!depsAreEqual(deps, updatedDeps)) {
            subscribers[watchName].deps = updatedDeps;
            fn();
          }
        }
      });
    }
  };
};

// node_modules/easy-reactive/src/utils/watcher.js
var createTargetWatcher = () => {
  let target = null;
  return {
    targetWatcher(watcherName, fn) {
      target = {
        watcherName,
        fn
      };
      target.fn();
      target = null;
    },
    getTarget() {
      return target;
    }
  };
};

// node_modules/easy-reactive/src/simply-reactive.js
function simplyReactive(entities, options) {
  const data = (0, import_lodash2.default)(entities, "data", {});
  const watch = (0, import_lodash2.default)(entities, "watch", {});
  const methods = (0, import_lodash2.default)(entities, "methods", {});
  const onChange = (0, import_lodash2.default)(options, "onChange", () => {
  });
  const { subscribe, notify, subscribers } = createSubscription();
  const { targetWatcher, getTarget } = createTargetWatcher();
  let _data;
  const _methods = {};
  const getContext = () => ({
    data: _data,
    methods: _methods
  });
  let callingMethod = false;
  const methodWithFlags = (fn) => (...args) => {
    callingMethod = true;
    const result = fn(...args);
    callingMethod = false;
    return result;
  };
  Object.entries(methods).forEach(([methodName, methodItem]) => {
    _methods[methodName] = methodWithFlags(
      (...args) => methodItem(getContext(), ...args)
    );
    Object.defineProperty(_methods[methodName], "name", { value: methodName });
  });
  _data = new Proxy((0, import_lodash3.default)(data), {
    get(target, prop) {
      if (getTarget() && !callingMethod) {
        subscribe(getTarget(), { prop, value: target[prop] });
      }
      return Reflect.get(...arguments);
    },
    set(target, prop, value) {
      if (target[prop] === value) {
        return true;
      }
      Reflect.set(...arguments);
      if (!getTarget()) {
        onChange && onChange(prop, value);
        notify(_data, prop);
      }
      return true;
    }
  });
  Object.entries(watch).forEach(([watchName, watchItem]) => {
    targetWatcher(watchName, () => {
      watchItem(getContext());
    });
  });
  const output = [_data, _methods];
  output._internal = {
    _getSubscribers() {
      return subscribers;
    }
  };
  return output;
}

export {
  simplyReactive
};
//# sourceMappingURL=chunk-UGDQHTTX.js.map
